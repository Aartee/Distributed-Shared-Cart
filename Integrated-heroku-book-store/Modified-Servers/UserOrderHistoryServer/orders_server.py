"""
This file contains the basic crud operations required for
the shopping cart module

_id -> primary key of the collection (automatically generated by
mongoDB)
userId -> getFromUserSessions
productId -> getFromProductCatalog
productName -> getFromProductCatalog
price -> getFromProductCatalog
quantity -> get from user on GUI of shopping cart or add to cart page
"""
from pymongo import MongoClient
from bson.objectid import ObjectId
from flask import Flask,render_template,jsonify,json,request
from fabric.api import *
from pprint import pprint
from bson.json_util import dumps
import ast
import uuid
app = Flask(__name__)

"""
mongo_cluster = ("mongodb://haroon:haroon@281-hackathon-shard-00-00-pjkz1.mongodb.net:27017,"
    "281-hackathon-shard-00-01-pjkz1.mongodb.net:27017,"
    "281-hackathon-shard-00-02-pjkz1.mongodb.net:27017"
    "/cmpe282?ssl=true&replicaSet=281-hackathon-shard-0&authSource=admin")
"""

#client = MongoClient(mongo_cluster)
client = MongoClient()
#Database name
db = client["financialData"]

#Collection name
myOrders = db["orderHistory"]

# Generates a new order ID
def generate_orderid():
    return str(uuid.uuid4())
"""
findProduct : returns the details of a product for
              a given user from the database
    userId    : user id for whom product details are needed
    productId : product whose details are required
"""

@app.route("/v1/cart/",methods=['GET'])
def findProduct():
    """
    NOTE: If we want to project only select few columns
    then use additional arg to find_one
    e.g. to include only userId and productId use:
    myCart.find_one({"userId":userId, "productId" : productId},
    {userId:1, productId:1, _id:0})
    """
    try:
        result = json.loads(request.get_data(as_text=True))

        print(str(result))
        userId = result['userId']
        productId = result['productId']
        item = myCart.find_one({"userId":long(userId), "productId" : long(productId)})
        print("find one success")
        data = dumps(item)
        print(str(item))
        return jsonify({"Status" : "OK", "data" : data})
    except Exception, e:
        return jsonify(status='ERROR',message=str(e))




@app.route("/v1/myOrders",methods=['POST'])
def getOrderDetails():
    """
    Displays the complete shopping cart for the user
    """
    try:
        result = json.loads(request.get_data(as_text=True))
        userId = request.json['userId']
        print("user id :"+userId)
        items = myOrders.find({"userId":userId})
        data = dumps(items)
        print(str(items))
        return jsonify({"Status" : "OK", "data" : data})
    except Exception, e:
        return jsonify(status='ERROR',message=str(e))


@app.route('/v1/order', methods=['POST'])
def insertOrUpdateOrder():

    try:
        result = json.loads(request.get_data(as_text=True))
        print(result)
        userId = request.json['userId']
        orderData = request.json['orderData']
        #orderData = ast.literal_eval(orderData)
        order = {}
        order['_id'] = generate_orderid()
        order['orderData'] = orderData
        order['timestamp'] = "timestamp"
        """
        output = myOrders.insert_many(orderData)
        print("insert many sucessful")
        print("Post sucessful")
        stats = myOrders.aggregate(
            [
                { "$match" : { "userId" : userId} },
                { "$group":          
                    {   
                        "_id": { "userId": "$userId" },
                        "totalAmount": 
                            { "$sum": 
                                 { "$multiply": [ "$price", "$quantity" ] }
                                 },
                        "totalQuantity": { "$sum": "$quantity" } }
                },
                
         ]
         )
        statistics = dumps(stats)
        """
        data = myOrders.insert_one(order)
        print(data)
        return jsonify({"Status" : "OK",
        "orderId":order['_id'], "timestamp":order['timestamp']})
    except Exception, e:
        return jsonify(status='ERROR',message=str(e))
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=2000)



